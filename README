遇到的问题如下：
# 自己实现链表
- 首先要注意链表与节点是要分开设计的
- 如果想要节点元素的指针也重载++，--操作，则应该再设计迭代器类
- 因为排序时使用的是快速排序，需要迭代器能够向前和向后访问，因此设计的链表是双向链表
- 如果链表为空，则begin与end应该返回同一个迭代器，即尾后迭代器，因此使用一个空节点作为尾后节点
- 因为插入元素是在指定元素之后插入，因此需要考虑链表为空的情况，这种情况出现的条件是begin()=end()
- 还是需要注意一下泛型类在类外定义成员函数时的问题，写法如下：
	template <typename T>
    list_node<T> * list<T>::insert(list_node<T> *pos, T t)
- 如果链表的空白节点不是动态分配的，而是作为一个成员，则析构函数的最后一句delete tail不能要，否则会将blank这个对象释放两次
- 关于排序，需要注意循环终止时不仅仅只有q->next==p,这种情况，在所有元素都小于等于第一个元素的情况下循环终止时是p==q

# 一元多项式的相加
- 重载输入输出运算符时需要注意，只能将它们重载为非成员函数
- 合并链表时如果以链表1作为判断的基准，则循环结束后需要判断一下链表2有没有走到终点
 